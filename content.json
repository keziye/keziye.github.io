{"pages":[],"posts":[{"title":"1001 A+B Format","text":"原题链接：1001 题目大意：给两个不超过int型的数字，以每三个数字输出一个逗号（从后往前）的格式输出二者之和（当然也不超过int格式的范围）。 Sample Input: 1-1000000 9 Sample Output: 1-999,991 思路：题目已经说明不会超过int格式范围，使用三个int型变量分别存储输入数据和二者加和，注意此时可以使用STL（标准模板库）中内置string类函数to_string()，其作用是将一个数字转换成string类，把加和转换成string类，最后注意控制string类的输出即可。 代码： 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; int temp=a+b; string str=to_string(temp); for(int i=0;i&lt;str.length();i++){ printf(\"%c\",str[i]); if(str[i]=='-') continue; if((i+1)%3==str.length()%3&amp;&amp;i!=str.length()-1) printf(\",\"); } return 0;} 行到水穷处，坐看云起时，一起进步,各位朋友。 《I Want To Break Free》","link":"/2019/09/13/1001-A-B-Format/"},{"title":"1004 Counting Leaves","text":"原题链接：1004 题目大意:给出一棵树，需要统计这棵树每一层的叶子节点（没有左右子树的结点）数目。 Sample Input: 122 101 1 02 Sample Output: 10 1 思路：这道题题目很好理解，但要解决如何存储一棵树，如何遍历整棵树来获得叶子节点的数目，每一层的叶节点个数如何存储？刚开始我也是一脸懵逼，甚至打算使用教科书上的结构体来做，后来接触到STL中的vector(向量)才感觉教材是真的中看不中用，生搬硬套教材行不通，要学会使用vector容器来存储树，至于怎么遍历，那就是DFS，遍历终点是碰到叶子节点，利用一个num数组来记录当前深度的叶节点个数，如果没有遇到叶节点就继续向下递归，由于需要记录的是每一层中的叶节点个数，所以需要在DFS函数里添加额外的变量depth，DFS每向下一层depth+1。题目要求需要输出每一层的个数，所以需要知道树总共又多深，所以还需要建立一个全局变量maxdepth来记录深度，同时也方便输出操作。 代码： 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=120;int num[maxn],n,m,maxdepth=-1;vector&lt;int&gt;a[maxn];void dfs(int index,int depth){ if(a[index].size()==0){ num[depth]++; if(depth&gt;maxdepth) maxdepth=depth; // return ; 可加可不加，会自动return 回上一层DFS函数 } for(int i=0;i&lt;a[index].size();i++){ dfs(a[index][i],depth+1); }}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++){ int k,root; cin&gt;&gt;root&gt;&gt;k; for(int j=0;j&lt;k;j++){ int node; cin&gt;&gt;node; a[root].push_back(node); } } dfs(1,1); for(int i=1;i&lt;=maxdepth;i++){ cout&lt;&lt;num[i]; if(i!=maxdepth) cout&lt;&lt;\" \"; } return 0;} Brave Shine 我想要一个Saber。","link":"/2019/09/13/1004-Counting-Leaves/"},{"title":"1002 A+B For Polynomials","text":"原题链接：1002 题目大意:给出两个多项式，需要计算这两个多项的和，题目中还隐含了一个条件，在输出时要按多项式指数从大到小输出，原题只说按照给出的格式输出，当初提交代码死活过不了，后来才发现输出是按指数递减序列输出，陈越姥姥出题不看仔细的话很有可能会被坑，当然，计算机从业人员最基本的严谨还是很重要的吧。 Sample Input: 122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output: 13 2 1.5 1 2.9 0 3.2 思路：使用hash表散列的思路，用一个double格式的数组来存每个项的系数，数组下标即为指数，输入一组数据直接加到所在指数中，最后从后往前输出即可。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1100;double a[maxn]={0.0};int n,m;int main(){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ int index; float num; cin&gt;&gt;index&gt;&gt;num; a[index]=num; } cin&gt;&gt;m; for(int i=0;i&lt;m;i++){ int index; float num; cin&gt;&gt;index&gt;&gt;num; a[index]+=num; } int count=0; for(int i=0;i&lt;maxn;i++){ if(a[i]!=0.0){ count++; } } cout&lt;&lt;count; for(int i=maxn-1;i&gt;=0;i--){ if(a[i]!=0.0){ printf(\" %d %.1f\",i,a[i]); } } return 0;}","link":"/2019/09/13/1002-A-B-For-Polynomials/"},{"title":"1003 Emergency","text":"原题链接：1003 题目大意:给出几个城市之间的路径与距离和这几个城市的权值，需要你在给出的起点和终点里寻找最短路径同时保证路径上经过的城市总权值尽可能大，输出最短路径条数和所有路径中的最大权值。 Sample Input: 123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output: 12 4 思路：典型的Dijkstra算法求最短路径，但题目除了要求路径最短外还有第二标尺，即路径上的权值之和要越大，还有一个额外工作统计最短路径条数，两种方法解决此类问题，Dijkstra算法或Dijkstra+DFS。 代码：Dijkstra算法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=999999;const int maxn=520;int a[maxn][maxn],weight[maxn],dis[maxn],num[maxn],w[maxn];bool vis[maxn];int n,m,st,ed;void dijkstra(int st){ fill(dis,dis+maxn,inf); fill(vis,vis+maxn,false); fill(w,w+maxn,0); fill(num,num+maxn,0); dis[st]=0; w[st]=weight[st]; num[st]=1; for(int i=0;i&lt;n;i++){ int u=-1,min=inf; for(int j=0;j&lt;n;j++){ if(vis[j]==false&amp;&amp;dis[j]&lt;min){ u=j; min=dis[j]; } } if(u==-1) return ; vis[u]=true; for(int v=0;v&lt;n;v++){ if(vis[v]==false&amp;&amp;a[u][v]!=inf){ if(dis[v]&gt;dis[u]+a[u][v]){ dis[v]=dis[u]+a[u][v]; w[v]=w[u]+weight[v]; num[v]=num[u]; }else if(dis[v]==dis[u]+a[u][v]){ if(w[v]&lt;w[u]+weight[v]){ w[v]=w[u]+weight[v]; } num[v]+=num[u]; //num[u]是到U的最短路径的条数，因为距离相等所以到u的条数等于到v的条数 } //但由于此时又有其他到V的路径长度一样所以加上其他到V的路径条数 } } }}int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;ed; fill(a[0],a[0]+maxn*maxn,inf); for(int i=0;i&lt;n;i++){ cin&gt;&gt;weight[i]; } for(int i=0;i&lt;m;i++){ int u,v,temp; cin&gt;&gt;u&gt;&gt;v&gt;&gt;temp; a[u][v]=a[v][u]=temp; } dijkstra(st); cout&lt;&lt;num[ed]&lt;&lt;\" \"&lt;&lt;w[ed]; return 0;} Dijksrta+DFS: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=999999;const int maxn=520;int a[maxn][maxn],weight[maxn],dis[maxn];int n,m,st,ed,num=0,maxWeight=-1;bool vis[maxn];vector&lt;int&gt;pre[maxn],temp;void dijkstra(int st){ fill(dis,dis+maxn,inf); fill(vis,vis+maxn,false); dis[st]=0; for(int i=0;i&lt;n;i++){ int u=-1,min=inf; for(int j=0;j&lt;n;j++){ if(vis[j]==false&amp;&amp;dis[j]&lt;min){ u=j; min=dis[j]; } } if(u==-1) return ; vis[u]=true; for(int v=0;v&lt;n;v++){ if(vis[v]==false&amp;&amp;a[u][v]!=inf){ if(dis[u]+a[u][v]&lt;dis[v]){ dis[v]=dis[u]+a[u][v]; pre[v].clear(); pre[v].push_back(u); }else if(dis[u]+a[u][v]==dis[v]) pre[v].push_back(u); } } }}void dfs(int index){ if(index==st){ temp.push_back(index); num++; int value=0; for(int i=temp.size()-1;i&gt;=0;i--){ value+=weight[temp[i]]; } if(value&gt;maxWeight) maxWeight=value; temp.pop_back(); return ; } temp.push_back(index); for(int i=0;i&lt;pre[index].size();i++){ dfs(pre[index][i]); } temp.pop_back();}int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;ed; fill(a[0],a[0]+maxn*maxn,inf); for(int i=0;i&lt;n;i++){ cin&gt;&gt;weight[i]; } for(int i=0;i&lt;m;i++){ int u,v,temp; cin&gt;&gt;u&gt;&gt;v&gt;&gt;temp; a[u][v]=a[v][u]=temp; } dijkstra(st); dfs(ed); cout&lt;&lt;num&lt;&lt;\" \"&lt;&lt;maxWeight; return 0;} 总结:比较两种算法，Dijkstra+DFS代码量要少一点，因为Dijkstra算法完成后得到的最短路径就是一棵树，使用DFS对树遍历时只需考虑第二标尺，就算在第二标尺的条件下还有第三标尺，第四标尺等等都可以使用这种思想，我的理解是相当与在一个集合里寻找符合第一标尺的结点构成的子集，然后在这个子集里寻找满足第二标尺的子集，依此类推。但Dijkstra不易出错，还是建议使用Dijkstra。 Right now,Please burn your soul,Neck or noting!BRE@TH//LESS","link":"/2019/09/13/1003-Emergency/"},{"title":"1005 Spell It Right","text":"原题链接：1005 题目大意:给出一个小于10^100的数，需要输出这个数每个数位加和的中文拼音。 Sample Input: 112345 Sample Output: 1one five 思路：使用简单hash散列来对应输出加和，由于数字太大用string类来存，对其遍历加和就行，总而言之是一道送分题（为什么今年九月的二十分题是送命题？？？）。 代码： 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;string str[10]={\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};string s;int main(){ cin&gt;&gt;s; int temp=0; for(int i=0;i&lt;s.length();i++){ temp+=s[i]-'0'; } string a=to_string(temp); for(int i=0;i&lt;a.length();i++){ cout&lt;&lt;str[a[i]-'0']; if(i!=a.length()-1) cout&lt;&lt;\" \"; } return 0;} 题外话，最近睡眠有点不好，真的怀念以前kfbx一起的日子，还有后期和强哥熊哥朱老板一起十点就熄灯睡觉的时光，现在来到本部不禁感叹鼾声阵阵，此起彼伏，夜夜失眠，都说同专业一起不会掉队，我发现搬来本部后除了收获到失眠也没有其他特别的，希望下周可以解决睡眠问题。 Anywhere I Go Tell me anywhere I go You will follow","link":"/2019/09/20/1005-Spell-It-Right/"},{"title":"1008 Elevator","text":"原题链接：1008 题目大意:对一个电梯进行简单模拟，电梯在每一层停留5秒，每上一层花6秒，每下一层花4秒，现在给出一个电梯的工作队列，需要计算电梯完成该队列的总时间。 Sample Input: 13 2 3 1 Sample Output: 141 思路：好像也没什么巧办法，一道送分题，只是有一种情况需要注意，有人会上电梯后不上也不下，带在里面或者出来，电梯就不上不下，这时候还是需要加5秒时间的，当初被这点坑了一把，也是服，不上也不下那他坐电梯干嘛？？？ 代码： 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,now=0,next,ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;next; if(next&gt;now) ans+=(next-now)*6+5; else ans+=(now-next)*4+5;//如果此处写成else if(next&lt;now)的话会少考虑上述有人上电梯不上不下的情况 now=next; } cout&lt;&lt;ans; return 0;} X You(Radio Edit) Avicii forever!","link":"/2019/09/20/1008-Elevator/"},{"title":"1006 Sign In and Sign Out","text":"原题链接：1006 题目大意:给出N个学生进出学校机房的时间，输出最早去机房和最晚离开机房的同学学号，时间的输入是以格式HH:MM:SS的格式输入，eg： 115:30:28 Sample Input: 12343CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40 Sample Output: 1SC3021234 CS301133 思路：两种做法：0.使用string类已经重载了的比较运算符来遍历整个输入，其中需要设置两个全局MinTime=23:59:59,MaxTime=00:00:00,string类内置的比较运算符比如”&lt;”,会从两个字符串的开始比较直到其中不相等为止。1.使用结构体，其实上述方法也是使用结构体，不过这个结构体里的类型格式是int而不是string，所以需要重载sort函数里的cmp函数，也挺简单，无非需要多做一点工作。 代码： string类的比较 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;string Min=\"23:59:59\",Max=\"00:00:00\";struct node{ string id,in,out;};int main(){ int m; cin&gt;&gt;m; node a[m]; string u,v; for(int i=0;i&lt;m;i++){ string id,in,out; cin&gt;&gt;id&gt;&gt;in&gt;&gt;out; a[i].id=id; a[i].in=in; a[i].out=out; } for(int i=0;i&lt;m;i++){ if(a[i].in&lt;Min){ Min=a[i].in; u=a[i].id; } } for(int i=0;i&lt;m;i++){ if(a[i].out&gt;Max){ Max=a[i].out; v=a[i].id; } } cout&lt;&lt;u&lt;&lt;\" \"&lt;&lt;v; return 0;} int类型+sort函数 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ string id; int ihh,imm,iss,ohh,omm,oss;};bool cmp1(node a,node b){ if(a.ihh!=b.ihh) return a.ihh&lt;b.ihh; else if(a.imm!=b.imm) return a.imm&lt;b.imm; return a.iss&lt;b.iss;}bool cmp2(node a,node b){ if(a.ohh!=b.ohh) return a.ohh&gt;b.ohh; else if(a.omm!=b.omm) return a.omm&gt;b.omm; return a.oss&gt;b.oss;}int main(){ int m; cin&gt;&gt;m; node a[m]; for(int i=0;i&lt;m;i++){ string id; int hh,mm,ss; cin&gt;&gt;id; a[i].id=id; scanf(\"%d:%d:%d\",&amp;hh,&amp;mm,&amp;ss); a[i].ihh=hh; a[i].imm=mm; a[i].iss=ss; scanf(\"%d:%d:%d\",&amp;hh,&amp;mm,&amp;ss); a[i].ohh=hh; a[i].omm=mm; a[i].oss=ss; } sort(a,a+m,cmp1); cout&lt;&lt;a[0].id&lt;&lt;\" \"; sort(a,a+m,cmp2); cout&lt;&lt;a[0].id; return 0;} Walk Thru Fire——by Vicetone","link":"/2019/09/20/1006-Sign-In-and-Sign-Out/"},{"title":"1007 Maximum Subsequence Sum","text":"原题链接：1007 题目大意:给出一串序列，需要找到其中最大子列和的加和以及该子列的左右序号。 Sample Input: 1210-10 1 2 3 4 -5 -23 3 7 -21 Sample Output: 110 1 4 思路：这是一道关于DP（Dynamic Programming）动态规划的题，不在pat甲级的考纲范围内，所以可以跳过，我还是把代码贴出来吧。有兴趣的朋友可以看看。先占坑，以后来更新。 代码： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { int n; scanf(\"%d\", &amp;n); vector&lt;int&gt; v(n); int leftindex = 0, rightindex = n - 1, sum = -1, temp = 0, tempindex = 0; for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;v[i]); temp = temp + v[i]; if (temp &lt; 0) { temp = 0; tempindex = i + 1; } else if (temp &gt; sum) { sum = temp; leftindex = tempindex; rightindex = i; } } if (sum &lt; 0) sum = 0; printf(\"%d %d %d\", sum, v[leftindex], v[rightindex]); return 0;} A Thousand Miles 个人最喜欢的版本 Do you think time Would pass me by Cause you know I’d walk A thousand miles If I could Just see you Tonight","link":"/2019/09/20/1007-Maximum-Subsequence-Sum/"},{"title":"1009 Product of Polynomials","text":"原题链接：1009 题目大意：给出两个多项式，需要给出二者相乘的结果，同1002，以指数非递增的格式输出指数和系数。 Sample Input: 122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output: 13 3 3.6 2 6.0 1 1.6 思路：同1002，利用hash散列表的思想，三个double型数组，a[maxn],b[maxn],c[maxn],分别存储两个多显示以及结果，对a和b进行遍历，其中c[i+j]+=a[i]*b[j]; 代码： 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1001;double a[maxn],b[maxn],c[maxn*2];int main(){ int k,exp,cnt=0; cin&gt;&gt;k; for(int i=0;i&lt;k;i++){ cin&gt;&gt;exp; cin&gt;&gt;a[exp]; } cin&gt;&gt;k; for(int i=0;i&lt;k;i++){ cin&gt;&gt;exp; cin&gt;&gt;b[exp]; } for(int i=0;i&lt;maxn;i++){ for(int j=0;j&lt;maxn;j++) c[i+j]+=a[i]*b[j]; } for(int i=0;i&lt;maxn*2;i++){ if(c[i]!=0) cnt++; } cout&lt;&lt;cnt; for(int i=maxn*2-1;i&gt;=0;i--){ if(c[i]!=0) printf(\" %d %.1f\",i,c[i]); } return 0;}","link":"/2019/09/28/1009-Product-of-Polynomials/"},{"title":"1012 The Best Rank","text":"原题链接：1012 题目大意：给出一些学生的学号和三门成绩，对他们进行排名，输出每个学生最好的排名，排名规则是这样的，除开C,M,E三种成绩外，还需获得每个学生的平均成绩，成绩之间是有优先级的，A&gt;C&gt;M&gt;E,如果一个学生几个成绩都一样那就输出优先级最高成绩排名，如果某一门成绩一样，那就并列一个名词，而下一个名次则是之前每个名次的人数总和，这样听起来比较麻烦，举个栗子，张三100分，李四100分，王五99分，那么张三李四都是第一名，而王五就是第三名了。 Sample Input: 1234567891011125 6310101 98 85 88310102 70 95 88310103 82 87 94310104 91 91 91310105 85 90 90310101310102310103310104310105999999 Sample Output: 1234561 C1 M1 E1 A3 AN/A 思路：一道排序题，需要对Algorithm头文件里sort函数中cmp函数的写法稍微改动一点。详细请看代码，这是关键,个人感觉排序题是最简单的一类题，理清逻辑就OK了。这题还稍微涉及一点hash的思想。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000000;int Hash[maxn],Index=0;char str[5]={'A','C','M','E'};struct node{ int id,grade[4],rank[4],best,tag;};bool cmp(node a,node b){ return a.grade[Index]&gt;b.grade[Index];}int main(){ fill(Hash,Hash+maxn,-1); int n,m; scanf(\"%d%d\",&amp;n,&amp;m); node a[n]; for(int i=0;i&lt;n;i++){ int id,temp,sum=0; scanf(\"%d\",&amp;a[i].id); Hash[a[i].id]=i; for(int j=1;j&lt;4;j++){ scanf(\"%d\",&amp;temp); sum+=temp; a[i].grade[j]=temp; } a[i].grade[0]=sum/3; } for(Index=0;Index&lt;4;Index++){ sort(a,a+n,cmp); a[0].rank[Index]=1; for(int i=1;i&lt;n;i++){ if(a[i].grade[Index]==a[i-1].grade[Index]) a[i].rank[Index]=a[i-1].rank[Index]; else a[i].rank[Index]=i+1; } } for(int i=0;i&lt;n;i++){ int best=99999,tag; for(int j=0;j&lt;4;j++){ if(a[i].rank[j]&lt;best){ best=a[i].rank[j]; tag=j; } } a[i].best=best; a[i].tag=tag; } for(int i=0;i&lt;m;i++){ int temp; scanf(\"%d\",&amp;temp); if(Hash[temp]==-1) printf(\"N/A\\n\"); else{ for(int j=0;j&lt;n;j++){ if(temp==a[j].id) printf(\"%d %c\\n\",a[j].best,str[a[j].tag]); } } } return 0;}","link":"/2019/09/28/1012-The-Best-Rank/"},{"title":"1013 Battle Over Cities","text":"原题链接：1013 题目大意：给几个相互连通的城市，如果其中某个城市被敌人占领，为了保持剩下的城市的连通性，需要求出额外建造多少条路。 Sample Input: 12343 2 31 21 31 2 3 Sample Output: 123100 思路：一道关于图的遍历的问题，大意就是去掉连通图中某个结点，问需要建立多少条路使该图保持连通。可以这么想，图中某个结点被删除以及和该结点相关的路被删除，被分成几个连通分量，有n个连通分量就需要额外建立n-1条路保证连通性。至于如何遍历那就采用DFS（深度优先搜索），每次遍历都把被占领的城市设置为已遍历，这样就已占领的城市就不会进入遍历。 代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1010;int n,m,k;bool vis[maxn];vector&lt;int&gt;v[maxn];void dfs(int index){ if(vis[index]==true) return ; vis[index]=true; for(int i=0;i&lt;v[index].size();i++){ dfs(v[index][i]); }}int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0;i&lt;m;i++){ int a,b; cin&gt;&gt;a&gt;&gt;b; v[a].push_back(b); v[b].push_back(a); } for(int i=0;i&lt;k;i++){ fill(vis,vis+maxn,false); int temp,cnt=0; cin&gt;&gt;temp; vis[temp]=true; for(int j=1;j&lt;=n;j++){ if(vis[j]!=true){ dfs(j); cnt++; } } cnt--; cout&lt;&lt;cnt&lt;&lt;endl; } return 0;}","link":"/2019/10/12/1013-Battle-Over-Cities/"},{"title":"1014 Waiting in Line","text":"原题链接：1014 题目大意：模拟一个银行排队，银行有N个服务窗口，每个窗口前有一条黄线把队列分成两个部分，排队规则如下，在每个窗口黄线里可以容纳M个顾客，因此当N个窗口被排满，那么下一位顾客（序号N*M+1）必须在黄线外等候服务。当每个顾客要进入黄线内时都会选择最短的队列排队，如果有两条队列长度一样，那么顾客就会选择编号最小的一条队列排队。每一名顾客都需要一定时间完成服务。第一个顾客假定在8：00到达。请计算出给出的查询编号顾客服务完成的时间，如果超出17：00，银行关闭，输出sorry。 Sample Input: 1232 2 7 51 2 6 4 3 534 23 4 5 6 7 Sample Output: 1234508:0708:0608:1017:00Sorry 思路：通过手动模拟，可以发现每次每个顾客都选择当前最优的情况，就是局部最优，所以可以使用一个数组记录每个顾客结束服务的时间，最后减去服务时间，如果大于17：00，输出sorry，小于则正常输出，需要注意对NM后的顾客入队顺序，有几个窗口就建立几个结构体（包含一条队列，窗口结束工作的时间，队列里每个当前队头出队的时间）。关于（NM）之后的顾客遍历顺序有点像Dijkstra的部分，详情请看代码，建议手动模拟一下案例。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1010;int n,m,k,query,q;int convertToMinute(int h,int m){ return h*60+m;} struct Window{ int endtime,poptime; queue&lt;int&gt;q;}window[20];int ans[maxn],needtime[maxn];int main(){ int Index=0; scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;k,&amp;query); for(int i=0;i&lt;k;i++){ scanf(\"%d\",&amp;needtime[i]); } for(int i=0;i&lt;n;i++){ window[i].endtime=window[i].poptime=convertToMinute(8,0); } for(int i=0;i&lt;min(n*m,k);i++){ window[Index%n].q.push(Index); window[Index%n].endtime+=needtime[Index]; if(Index&lt;n) window[Index%n].poptime=needtime[Index]; ans[Index]=window[Index%n].endtime; Index++; } for(;Index&lt;k;Index++){ int idx=-1,minPoptime=1&lt;&lt;30; for(int i=0;i&lt;n;i++){ if(window[i].poptime&lt;minPoptime){ idx=i; minPoptime=window[i].poptime; } } Window&amp; w=window[idx]; w.q.pop(); w.q.push(Index); w.endtime+=needtime[Index]; w.poptime+=needtime[w.q.front()]; ans[Index]=w.endtime; } for(int i=0;i&lt;query;i++){ scanf(\"%d\",&amp;q); if(ans[q-1]-needtime[q-1]&gt;=convertToMinute(17,0)){ printf(\"Sorry\\n\"); }else{ printf(\"%02d:%02d\\n\",ans[q-1]/60,ans[q-1]%60); } } return 0;}","link":"/2019/10/12/1014-Waiting-in-Line/"},{"title":"1015 Reversible Primes","text":"原题链接：1015 题目大意：判断一个数在十进制下和给定radix下逆置后是不是素数，若都为素数输出yes,否则输出no。 Sample Input: 123473 1023 223 10-2 Sample Output: 123YesYesNo 思路：把十进制数转换成其他进制，再把其他进制数逆置后转换成十进制并判断各自是否为素数,听起来很复杂其实大家都会做对不对。直接上代码。 代码： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;bool isPrime(int a){ if(a&lt;2) return false; for(int i=2;i*i&lt;=a;i++){ if(a%i==0) return false; } return true;} int todecimal(string str,int radix){ int ans=0,temp=stoi(str); while(temp){ ans=ans*radix+temp%radix; temp/=radix; } return ans;}int main(){ string str; int radix; while(true){ cin&gt;&gt;str; if(str[0]=='-') return 0; cin&gt;&gt;radix; if(isPrime(stoi(str))&amp;&amp;isPrime(todecimal(str,radix))) cout&lt;&lt;\"Yes\"&lt;&lt;endl; else cout&lt;&lt;\"No\"&lt;&lt;endl; } return 0;}","link":"/2019/10/12/1015-Reversible-Primes/"},{"title":"1017 Queueing at Bank","text":"原题链接：1017 题目大意：给出n个去银行排队需要服务的顾客到达银行以及需要服务的时间，请给出这些顾客的平均等待时间，和1014一样，到达时间超过17：00停止服务，不计入统计。 Sample Input: 123456787 307:55:00 1617:00:01 207:59:59 1508:01:00 6008:00:00 3008:00:02 208:03:00 10 Sample Output: 18.2 思路:这道题相比1014来说简单了不少，使用结构体分别存储每个顾客到达时间和服务时间，用vector装入这些结点，根据到达时间排序，使用一个数组存储每个窗口结束当前工作的时间，在遍历寻找最优队列让顾客排队时需要注意，如果顾客到来时有空闲窗口，那么这个窗口结束工作时间就要到该顾客结束服务的时间（包涵了到达时间），相反顾客到达时没有空队列那么必须等待，此时寻找到的最优窗口只需加上服务时间即可，仔细想象平时的排队经历是很容易理解的，生活中往往我们觉得很平常的事物可能正是我们不了解的。最好可以手动模拟一次。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ int cometime,servetime;};int endtime[120],c,w,total=0;vector&lt;node&gt;v;int convertTime(int h,int m,int s){ return h*3600+m*60+s;}bool cmp(node a,node b){ return a.cometime&lt;b.cometime;}int main(){ cin&gt;&gt;c&gt;&gt;w; int stTime=convertTime(8,0,0); int edTime=convertTime(17,0,0); for(int i=0;i&lt;w;i++) endtime[i]=stTime; for(int i=0;i&lt;c;i++){ int h,m,s,serveTime; scanf(\"%d:%d:%d %d\",&amp;h,&amp;m,&amp;s,&amp;serveTime); int cometime=convertTime(h,m,s); if(cometime&gt;edTime) continue; node temp; temp.cometime=cometime; temp.servetime=serveTime&lt;=60? serveTime*60:3600; v.push_back(temp); } sort(v.begin(),v.end(),cmp); for(int i=0;i&lt;v.size();i++){ int Index=-1,minTime=1&lt;&lt;31-1; for(int j=0;j&lt;w;j++){ if(endtime[j]&lt;minTime){ minTime=endtime[j]; Index=j; } } if(endtime[Index]&lt;=v[i].cometime) endtime[Index]=v[i].cometime+v[i].servetime; else{ total+=(endtime[Index]-v[i].cometime); endtime[Index]+=v[i].servetime; } } if(v.size()==0) printf(\"0.0\"); else printf(\"%.1f\",total/60.0/v.size()); return 0;}","link":"/2019/10/12/1017-Queueing-at-Bank/"},{"title":"1010 Radix","text":"原题链接：1010 题目大意：给出两个范围在1&lt;&lt;64-1（超过int格式范围）范围内的正数，以及一个radix（其中某个数的进制），需要判断判断另一个数在某种进制中和已知进制数是否相等，相等输出另一个数的radix。 Sample Input 1: 16 110 1 10 Sample Output 1: 12 Sample Input 2: 11 ab 1 2 Sample Output 2: 1Impossible 思路：分析题目，是求一个未知进制的数在某一进制下是否与已知进制的数相等，当然都需要换成同一进制，比如十进制，首先需要考虑如何找到未知进制，因为不可能从2开始一直遍历吧，这样一定会超时，何况给的数据有可能使计算机溢出，所以考虑到二分法寻找进制，那么进制范围呢？即二分范围，考虑到已知进制数（已转成十进制）大小和未知进制数中数字最大的数字+1（想想为什么是未知进制数中最大数字+1），所以二分上限是max(已知数，未知数数字最大数+1)；下限是未知数中最大数字+1；为什么范围是这两个呢？首先，因为未知进制不可能小于等于未知数中最大的数，如果小于等于的话就不是这个数，早就有进位了，其中由于需要让两个数相等，所以在求解未知进制还要考虑已知数的大小，比如36（Decimal）和1（Unknown Radix），那么1在36进制下就等于36。题目给的数据范围是1&lt;&lt;64-1，故用long long 类型存储数据。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;long long todecimal(string str,long long radix){ long long ans=0; for(int i=0;i&lt;str.length();i++){ if(isdigit(str[i])) ans=ans*radix+str[i]-'0'; else ans=ans*radix+str[i]-'a'+10; } return ans;}int main(){ string a,b; long long radix,tag,n1,n2; cin&gt;&gt;a&gt;&gt;b&gt;&gt;tag&gt;&gt;radix; if(tag==2) swap(a,b); n1=todecimal(a,radix); long long left=0,temp; for(int i=0;i&lt;b.length();i++){ if(isdigit(b[i])) temp=b[i]-'0'; else temp=b[i]-'a'+10; if(temp&gt;left) left=temp; } left++; long long right=max(left,n1); while(left&lt;=right){ long long mid=(left+right)/2; n2=todecimal(b,mid); if(n2==n1) {cout&lt;&lt;mid; return 0;} else if(n2&gt;n1||n2&lt;0) right=mid-1; else if(n2&lt;n1) left=mid+1; } cout&lt;&lt;\"Impossible\"; return 0;} 注意:二分范围是left&lt;=right（请思考为什么加等号），在判断n1,n2的相对大小时有一个条件n2&lt;0，这是因为当一个正数在计算机里变成负数时表明这个正数溢出了，至于为什么，需要各位去看看《计算机组成原理》里关于计算机内部码制以及数据在计算机内部的表示方法，这里就不再提及，你只需要知道正数在计算机里变成负数表示这个正数比这种型号的计算机能够表示的最大正数还要大，负数变成正数一样的意思。","link":"/2019/09/28/1010-Radix/"},{"title":"1011 World Cup Betting","text":"原题链接：1011 题目大意：给出三列数据，再每列数据中找到最大的数字，然后将这些数字根据给出的公式计算结果，然后每个数字分别对应一个字母，同时输出最大数对应的字母和最终结果。 Sample Input: 1231.1 2.5 1.71.2 3.1 1.64.1 1.2 1.1 Sample Output: 1T T W 39.31 思路：至于思路，好像也没什么思路，一道送分题，输出字母用hash，每轮遍历结束将结果累乘就行。 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ double game; double ans=1.0; for(int i=0;i&lt;3;i++){ double temp=0.0; int index; for(int j=0;j&lt;3;j++){ cin&gt;&gt;game; if(temp&lt;game){ temp=game; index=j; } } ans*=temp; if(index==0) cout&lt;&lt;\"W\"&lt;&lt;\" \"; else if(index==1) cout&lt;&lt;\"T\"&lt;&lt;\" \"; else cout&lt;&lt;\"L\"&lt;&lt;\" \"; } printf(\"%.2f\",(ans*0.65-1)*2); return 0;}","link":"/2019/09/28/1011-World-Cup-Betting/"},{"title":"1020 Tree Traversals","text":"原题链接：1020 题目大意：给出一棵二叉树的后序和中序遍历，需要输出层序遍历的序列。 Sample Input: 12372 3 1 5 7 6 41 2 3 4 5 6 7 Sample Output: 14 1 6 3 5 7 2 思路:根据中序+其他序（前，后，层）来建立一棵树，然后使用BFS（广度优先搜索）即可完成要求，这里只想提一下结合中序+其他序建树课本里有讲过，我也就不重复了，上代码。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=55;int post[maxn],in[maxn],n;struct node{ int data; node *left,*right;}; node* create(int postL,int postR,int inL,int inR){ if(postL&gt;postR) return NULL; node* root=new node; root-&gt;data=post[postR]; root-&gt;left=root-&gt;right=NULL; int k; for(k=inL;k&lt;=inR;k++){ if(in[k]==post[postR]) break; } root-&gt;left=create(postL,postL+k-inL-1,inL,k-1); //k-inL代表左子树有多少个结点,其中包含了postL,所以要减一 root-&gt;right=create(postL+k-inL,postR-1,k+1,inR); return root;}void BFS(node* root){ queue&lt;node*&gt;q; q.push(root); int num=0; while(!q.empty()){ node* temp; temp=q.front(); cout&lt;&lt;temp-&gt;data; num++; if(num&lt;n) cout&lt;&lt;\" \"; q.pop(); if(temp-&gt;left!=NULL) q.push(temp-&gt;left); if(temp-&gt;right!=NULL) q.push(temp-&gt;right); }}int main(){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;post[i]; } for(int i=0;i&lt;n;i++){ cin&gt;&gt;in[i]; } node* root=create(0,n-1,0,n-1); BFS(root); return 0; }","link":"/2019/10/12/1020-Tree-Traversals/"},{"title":"1021 Deepest Root","text":"原题链接：1021 题目大意：给出一张图，这里想不出来该怎么表达“一个”图的说法，“一张”显得有点不够专业，所以说我还是太菜了。言归正传，需要给出这张图里可以构成的最深的树的根，有多个根结点深度一样，就按升序输出根节点编号，如果这幅图不是连通图那就输出ERROR以及最大联通子块的数目。 Sample Input1: 1234551 21 31 42 5 Sample Output1: 123345 Sample Input2: 1234551 31 42 53 4 Sample Output2: 1Error: 2 components 思路:使用DFS（深度优先搜索）来遍历整幅图，把当前最深树的序列存到一个向量中，再从这个向量里随便选一个结点作为根节点进行DFS，并把结果和上次遍历的结果取交集就OK了，这里要提一下为什么要遍历两次并且还要取两次的交集，你想啊，一棵树里的最深的那条路径的叶子节点是不是可以反过来看作一个根节点，从这个根节点再来一次DFS，因为DFS是遍历完整个图，所以这次的结果肯定包涵上次的结果，但也有可能包涵其他同样深度的树，而其他同样深度的树是不是也可以这么反过来看？所以要取两次遍历的交集。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1010;bool vis[maxn];vector&lt;int&gt;v[maxn],temp;set&lt;int&gt;st;int n,maxdepth=0;void DFS(int index,int depth){ if(depth&gt;maxdepth){ maxdepth=depth; temp.clear(); temp.push_back(index); }else if(depth==maxdepth) temp.push_back(index); vis[index]=true; for(int i=0;i&lt;v[index].size();i++){ if(vis[v[index][i]]==false) DFS(v[index][i],depth+1); }}int main(){ cin&gt;&gt;n; for(int i=1;i&lt;n;i++){ int a,b; cin&gt;&gt;a&gt;&gt;b; v[a].push_back(b); v[b].push_back(a); } int cnt=0; fill(vis,vis+maxn,false); for(int i=1;i&lt;=n;i++){ if(vis[i]==false){ DFS(i,1); cnt++; } } if(cnt&gt;1){ cout&lt;&lt;\"Error: \"&lt;&lt;cnt&lt;&lt;\" components\"; return 0; } fill(vis,vis+maxn,false); for(int i=0;i&lt;temp.size();i++) st.insert(temp[i]); int k=temp[0]; temp.clear(); maxdepth=0; DFS(k,1); for(int i=0;i&lt;temp.size();i++) st.insert(temp[i]); for(auto it=st.begin();it!=st.end();it++){ cout&lt;&lt;*it&lt;&lt;endl; } return 0;}","link":"/2019/10/19/1021-Deepest-Root/"},{"title":"1022 Digital Library","text":"原题链接：1022 题目大意：模拟图书馆里的查询系统，给出一些书的关键字，比如书名，作者，出版社，出版年份等等，需要根据给出的查询关键字输出书的编号,如果不存在该关键字则输出Not Found。 Sample Input: 123456789101112131415161718192021222324252631111111The Testing BookYue Chentest code debug sort keywordsZUCS Print20113333333Another Testing BookYue Chentest code sort keywordsZUCS Print220122222222The Testing BookCYLLkeywords debug bookZUCS Print2201161: The Testing Book2: Yue Chen3: keywords4: ZUCS Print5: 20113: blablabla Sample Output: 12345678910111213141516171: The Testing Book111111122222222: Yue Chen111111133333333: keywords1111111222222233333334: ZUCS Print11111115: 2011111111122222223: blablablaNot Found 思路:这是一道需要使用STL里的map（映射）容器来做的题，建立一个关键字与书号的映射，因为map里自动排序（map内部实现是红黑树），所以一举两得，最后查询只需要输出每个映射里的值（value），这里每个查询就是键（key）。这里要注意两个点，第一，如果使用string类来表示每个输入，因为cin遇空格终止输入所以要用getline(cin,string_type);来写入数据，还有就是关于getchar();接受没有用的回车键，还有关于数据里key的输入利用getchar();来判断当前是否要结束输入key。 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;string,set&lt;int&gt;&gt;mp;int n,id;string title,year,publish,auther,key;int main(){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;id; getchar(); getline(cin,title); mp[title].insert(id); getline(cin,auther); mp[auther].insert(id); while(true){ cin&gt;&gt;key; char c=getchar(); mp[key].insert(id); if(c=='\\n') break; } getline(cin,publish); mp[publish].insert(id); getline(cin,year); mp[year].insert(id); } int query; cin&gt;&gt;query; for(int i=1;i&lt;=query;i++){ int Index; string Query; scanf(\"%d: \",&amp;Index); getline(cin,Query); cout&lt;&lt;Index&lt;&lt;\": \"&lt;&lt;Query&lt;&lt;endl; if(mp.find(Query)!=mp.end()){ for(auto it=mp[Query].begin();it!=mp[Query].end();it++) printf(\"%07d\\n\",*it); }else printf(\"Not Found\\n\"); } return 0;}","link":"/2019/10/19/1022-Digital-Library/"},{"title":"1023 Have Fun With Numbers","text":"原题链接：1023 题目大意：给出一个包涵0-9全部数字且不重复的树，将它乘以2之后是否也是一个包涵0-9且不重复的数？ Sample Input: 11234567899 Sample Output: 12Yes2469135798 思路:利用两个Hash表来存储原数字和乘二后的数字个数，再做比较。 代码： 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int hash1[10],hash2[10];int main(){ string a; cin&gt;&gt;a; int carry=0,ans[22]; for(int i=a.size()-1;i&gt;=0;i--){ hash1[a[i]-'0']++; ans[i]=2*(a[i]-'0')+carry; if(ans[i]&gt;=10) { ans[i]-=10; carry=1; } else carry=0; hash2[ans[i]]++; } if(carry==1) printf(\"No\\n\"); else{ int flag=1; for(int i=0;i&lt;10;i++) if(hash1[i]!=hash2[i]) { flag=0; break;} if(flag) printf(\"Yes\\n\"); else printf(\"No\\n\"); } for(int i=0;i&lt;a.size();i++) printf(\"%d\",ans[i]); return 0;}","link":"/2019/10/19/1023-Have-Fun-With-Numbers/"},{"title":"1024 Palindromic Number","text":"原题链接：1024 题目大意：判断一个数经过不超过N次与自身反转的数字相加后是否是一个回文数，举个栗子，67（N=3），67+76=143，143+341=484，484是回文数，输出484和2（只用了2步），如果到达N步，输出当前数字以及使用步骤次数，终止。 Sample Input1: 167 3 Sample Output1: 124842 Sample Input2: 169 3 Sample Output2: 1213533 思路:使用string类进行操作，详细看代码，关于string类代表数字相加的方法。 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;bool is_HeiWen(string str){ for(int i=0;i&lt;str.length()/2;i++){ if(str[i]!=str[str.length()-1-i]) return false; } return true;}string add_string(string a,string b){ int len=a.length(),carry=0; string ans; for(int i=len-1;i&gt;=0;i--){ int temp=a[i]+b[i]-'0'-'0'+carry; ans=ans+to_string(temp%10); carry=temp/10; } if(carry&gt;0) ans+=\"1\"; reverse(ans.begin(),ans.end()); return ans;}int main(){ string a,b,ans; int Index,cnt; cin&gt;&gt;a&gt;&gt;cnt; if(is_HeiWen(a)){ cout&lt;&lt;a&lt;&lt;endl&lt;&lt;\"0\"; return 0; } for(Index=1;Index&lt;=cnt;Index++){ b=a; reverse(a.begin(),a.end()); ans=add_string(a,b); if(is_HeiWen(ans)||Index==cnt) break; a=ans; } cout&lt;&lt;ans&lt;&lt;endl&lt;&lt;Index; return 0;}","link":"/2019/10/19/1024-Palindromic-Number/"},{"title":"1074 Reversing Linked List","text":"原题链接：1074 题目大意：将一个有N个结点的链表分成块，每块有K个结点，把这些块从头到尾输出，每块里的结点倒序输出，注意，最后不足K个结点的块正序输出。 Sample Input: 123456700100 6 400000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218 Sample Output: 12345600000 4 3321833218 3 1230912309 2 0010000100 1 9999999999 5 6823768237 6 -1 思路:类似冬季第二题，可以直接在遍历链表时输出，但这样会麻烦一点，建议使用向量根据要求分块把每块结点按规则存储最后输出即可。注意无效结点。 代码： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ int address,data,next;}List[102400];int st,n,k;vector&lt;node&gt;temp,ans;int main(){ scanf(\"%d%d%d\",&amp;st,&amp;n,&amp;k); for(int i=0;i&lt;n;i++){ int address; scanf(\"%d\",&amp;address); List[address].address=address; scanf(\"%d%d\",&amp;List[address].data,&amp;List[address].next); } while(st!=-1) { temp.push_back(List[st]); st=List[st].next; } int block=temp.size()/k; for(int i=0;i&lt;block;i++){ for(int j=(i+1)*k-1;j&gt;=i*k;j--) ans.push_back(temp[j]); } if(temp.size()%k!=0){ for(int i=block*k;i&lt;temp.size();i++) ans.push_back(temp[i]); } for(int i=0;i&lt;ans.size();i++){ if(i!=ans.size()-1) printf(\"%05d %d %05d\\n\",ans[i].address,ans[i].data,ans[i+1].address); else printf(\"%05d %d -1\\n\",ans[i].address,ans[i].data); } return 0;}","link":"/2020/03/10/1074-Reversing-Linked-List/"},{"title":"1016 Phone Bills","text":"原题链接：1016 题目大意：给一串通话记录，需要给出每个用户每个月的花费。其中每个用户正确的通话记录先由“on-line”再到“off-line”，其中需要两条记录相邻，因为这样一对记录才是正常的，如果有“on-line”没有“off-line”匹配就算记录作废，反之“off-line”亦然。另外也给出了每个月的费率。 Sample Input: 12345678910111210 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 1010CYLL 01:01:06:01 on-lineCYLL 01:28:16:05 off-lineCYJJ 01:01:07:00 off-lineCYLL 01:01:08:03 off-lineCYJJ 01:01:05:59 on-lineaaa 01:01:01:03 on-lineaaa 01:02:00:01 on-lineCYLL 01:28:15:41 on-lineaaa 01:05:02:24 on-lineaaa 01:04:23:59 off-line Sample Output: 12345678910CYJJ 0101:05:59 01:07:00 61 $12.10Total amount: $12.10CYLL 0101:06:01 01:08:03 122 $24.4028:15:41 28:16:05 24 $3.85Total amount: $28.25aaa 0102:00:01 04:23:59 4318 $638.80Total amount: $638.80 思路:先进行排序，相邻两个结点前一个为“on-line”状态后一个为“off-line”才可以进入getsum函数进行per minute的累加，直到两个状态时间相同,注意日期的进位。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ string id,status; int month,dd,hh,mm;}res[1010];int n,toll[24];bool cmp(node a,node b){ if(a.id!=b.id) return a.id&lt;b.id; else if(a.month!=b.month) return a.month&lt;b.month; else if(a.dd!=b.dd) return a.dd&lt;b.dd; else if(a.hh!=b.hh) return a.hh&lt;b.hh; else return a.mm&lt;b.mm;}void getSum(node a,node b,int&amp; time,int&amp; money){ while(a.dd!=b.dd||a.hh!=b.hh||a.mm!=b.mm){ money+=toll[a.hh]; time++; a.mm++; if(a.mm==60){ a.mm=0; a.hh++; } if(a.hh==24){ a.hh=0; a.dd++; } }}int main(){ for(int i=0;i&lt;24;i++) cin&gt;&gt;toll[i]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;res[i].id; scanf(\"%d:%d:%d:%d\",&amp;res[i].month,&amp;res[i].dd,&amp;res[i].hh,&amp;res[i].mm); cin&gt;&gt;res[i].status; } sort(res,res+n,cmp); int flag=0,totle=0; for(int i=0;i&lt;n;i++){ if(res[i].id==res[i+1].id&amp;&amp;res[i].status==\"on-line\"&amp;&amp;res[i+1].status==\"off-line\"){ if(flag==0){ printf(\"%s %02d\\n\",res[i].id.c_str(),res[i].month); flag=1; } printf(\"%02d:%02d:%02d %02d:%02d:%02d \",res[i].dd,res[i].hh,res[i].mm,res[i+1].dd,res[i+1].hh,res[i+1].mm); int time=0,money=0; getSum(res[i],res[i+1],time,money); totle+=money; printf(\"%d $%.2f\\n\",time,money/100.0); }else if(res[i].id!=res[i+1].id){ if(flag==1) printf(\"Total amount: $%.2f\\n\",totle/100.0); totle=0; flag=0; } } return 0;}","link":"/2019/10/12/1016-Phone-Bills/"},{"title":"Hello World","text":"这几天每晚花两小时终于搭好了个人博客，同时 看到浏览器里自己的博客加载下来时，突然有种错综复杂的恍惚感，我好饿啊。 1Hello World. keziye 2019.07.06","link":"/2019/07/06/hello%20world/"},{"title":"冬季7-1","text":"Good in C When your interviewer asks you to write “Hello World” using C, can you do as the following figure shows? Input Specification: Each input file contains one test case. For each case, the first part gives the 26 capital English letters A-Z, each in a 7×5 matrix of C’s and .’s. Then a sentence is given in a line, ended by a return. The sentence is formed by several words (no more than 10 continuous capital English letters each), and the words are separated by any characters other than capital English letters. It is guaranteed that there is at least one word given. Output Specification: For each word, print the matrix form of each of its letters in a line, and the letters must be separated by exactly one column of space. There must be no extra space at the beginning or the end of the word. Between two adjacent words, there must be a single empty line to separate them. There must be no extra line at the beginning or the end of the output. Sample Input: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183..C...C.C.C...CCCCCCC...CC...CC...CCCCC.C...CC...CCCCC.C...CC...CCCCC..CCC.C...CC....C....C....C...C.CCC.CCCC.C...CC...CC...CC...CC...CCCCC.CCCCCC....C....CCCC.C....C....CCCCCCCCCCC....C....CCCC.C....C....C....CCCC.C...CC....C.CCCC...CC...CCCCC.C...CC...CC...CCCCCCC...CC...CC...CCCCCC..C....C....C....C....C..CCCCCCCCCC....C....C....C....CC...C.CCC.C...CC..C.C.C..CC...C.C..C..C.C...CC....C....C....C....C....C....CCCCCC...CC...CCC.CCC.C.CC...CC...CC...CC...CC...CCC..CC.C.CC..CCC...CC...C.CCC.C...CC...CC...CC...CC...C.CCC.CCCC.C...CC...CCCCC.C....C....C.....CCC.C...CC...CC...CC.C.CC..CC.CCC.CCCC.C...CCCCC.CC...C.C..C..C.C...C.CCC.C...CC.....CCC.....CC...C.CCC.CCCCC..C....C....C....C....C....C..C...CC...CC...CC...CC...CC...C.CCC.C...CC...CC...CC...CC...C.C.C...C..C...CC...CC...CC.C.CCC.CCC...CC...CC...CC...C.C.C...C...C.C.C...CC...CC...CC...C.C.C...C....C....C....C..CCCCC....C...C...C...C...C....CCCCCHELLO~WORLD! Sample Output: 123456789101112131415C...C CCCCC C.... C.... .CCC.C...C C.... C.... C.... C...CC...C C.... C.... C.... C...CCCCCC CCCC. C.... C.... C...CC...C C.... C.... C.... C...CC...C C.... C.... C.... C...CC...C CCCCC CCCCC CCCCC .CCC.C...C .CCC. CCCC. C.... CCCC.C...C C...C C...C C.... C...CC...C C...C CCCC. C.... C...CC.C.C C...C CC... C.... C...CCC.CC C...C C.C.. C.... C...CC...C C...C C..C. C.... C...CC...C .CCC. C...C CCCCC CCCC. 题目大意:给每个字母都设定一种由‘C’和‘.’组成的图像，而后给出一句话，要求将这句话里每个单词按规定输出。 思路：以前没遇到过这种输出方式可能会花点时间，用一个向量装入每个单词，然后从头开始遍历输出即可，需要注意的是，应该将每个单词一排一排输出，从上到下，不能一个字母接着一个字母输出，这样会出错。 代码： 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;string Hash[26][7],str;vector&lt;string&gt;ans;int main(){ for(int i=0;i&lt;26;i++){ for(int j=0;j&lt;7;j++) cin&gt;&gt;Hash[i][j]; } getchar(); getline(cin,str); string temp; for(int i=0;i&lt;str.size();i++){ if(!isupper(str[i])){ if(temp.size()!=0) { ans.push_back(temp); temp.clear(); } }else temp+=str[i]; } if(temp.size()!=0) ans.push_back(temp); for(int i=0;i&lt;ans.size();i++){ for(int j=0;j&lt;7;j++){ for(int k=0;k&lt;ans[i].size();k++){ if(k&lt;ans[i].size()-1) printf(\"%s \",Hash[ans[i][k]-'A'][j].c_str()); else printf(\"%s\\n\",Hash[ans[i][k]-'A'][j].c_str()); } } if(i&lt;ans.size()-1) printf(\"\\n\"); } return 0;}","link":"/2020/03/09/%E5%86%AC%E5%AD%A37-1/"},{"title":"冬季7-3","text":"Summit A summit (峰会) is a meeting of heads of state or government. Arranging the rest areas for the summit is not a simple job. The ideal arrangement of one area is to invite those heads so that everyone is a direct friend of everyone. Now given a set of tentative arrangements, your job is to tell the organizers whether or not each area is all set. Input Specification: Each input file contains one test case. For each case, the first line gives two positive integers N (≤ 200), the number of heads in the summit, and M, the number of friendship relations. Then M lines follow, each gives a pair of indices of the heads who are friends to each other. The heads are indexed from 1 to N. Then there is another positive integer K (≤ 100), and K lines of tentative arrangement of rest areas follow, each first gives a positive number L (≤ N), then followed by a sequence of L distinct indices of the heads. All the numbers in a line are separated by a space. Output Specification: For each of the K areas, print in a line your advice in the following format: 1.if in this area everyone is a direct friend of everyone, and no friend is missing (that is, no one else is a direct friend of everyone in this area), print Area X is OK.. 2.if in this area everyone is a direct friend of everyone, yet there are some other heads who may also be invited without breaking the ideal arrangement, print Area X may invite more people, such as H. where H is the smallest index of the head who may be invited. 3.if in this area the arrangement is not an ideal one, then print Area X needs help. so the host can provide some special service to help the heads get to know each other. Here X is the index of an area, starting from 1 to K. Sample Input: 1234567891011121314151617188 105 67 86 43 64 52 38 22 75 33 464 5 4 3 63 2 8 72 2 31 12 4 63 3 2 1 Sample Output: 123456Area 1 is OK.Area 2 is OK.Area 3 is OK.Area 4 is OK.Area 5 may invite more people, such as 3.Area 6 needs help. 题目大意:现在有一场峰会需要来安排邀请的地区，这些地区构成一张图，每个地区都有一个编号，如果邀请的每个地区之间都有直接连接且除了这些地区外再也没有任何一个地区和邀请的所有地区直接连接，就表明这个邀请时成功的，但存在任何一个地区和邀请的所有地区都有直接连接，则表明这个邀请需要邀请更多的地区，不过只需要邀请编号最小的那个地区，其余情况表示这份邀请需要帮助。说了这么多，就是一个模拟题，题库里后55道题有几道类似的，给一个新的知识点，多半与图或者树的性质类似，做这种题读懂题目很关键，读懂题目一遍AC。此题类似模拟最大联通子图，但也不完全是。 思路：二维数组建里关系，每输入一组数据就开始遍历每个序号，如果其中有结点之间没有直接联系则表明需要帮助，没问题但存在结点和邀请结点都有直接关系表示需要多邀请，以上全部满足则表明可行。 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,query,adj[256][256];int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=0;i&lt;m;i++){ int u,v; scanf(\"%d%d\",&amp;u,&amp;v); adj[u][v]=adj[v][u]=1; } scanf(\"%d\",&amp;query); for(int i=1;i&lt;=query;i++){ int k,Hash[n+1]={0},flag=1,ok=1,ans; vector&lt;int&gt;temp; scanf(\"%d\",&amp;k); for(int j=0;j&lt;k;j++) { int data; scanf(\"%d\",&amp;data); Hash[data]=1; temp.push_back(data); } for(int j=0;j&lt;temp.size();j++){ if(flag==0) break; for(int s=j+1;s&lt;temp.size();s++){ if(adj[temp[j]][temp[s]]==0) { flag=0; break; } } } if(flag==0) printf(\"Area %d needs help.\\n\",i); else{ for(int j=1;j&lt;=n;j++){ if(Hash[j]==0){ int s; for(s=0;s&lt;temp.size();s++){ if(adj[j][temp[s]]==0) break; } if(s==temp.size()) { ok=0; ans=j; break; } } } if(ok==1) printf(\"Area %d is OK.\\n\",i); else printf(\"Area %d may invite more people, such as %d.\\n\",i,ans); } } return 0;}","link":"/2020/03/09/%E5%86%AC%E5%AD%A37-3/"},{"title":"冬季7-2","text":"Block Reversing Given a singly linked list L. Let us consider every K nodes as a block (if there are less than K nodes at the end of the list, the rest of the nodes are still considered as a block). Your job is to reverse all the blocks in L. For example, given L as 1→2→3→4→5→6→7→8 and K as 3, your output must be 7→8→4→5→6→1→2→3. Input Specification: Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤105) which is the total number of nodes, and a positive K (≤N) which is the size of a block. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1. Then N lines follow, each describes a node in the format: 1Address Data Next where Address is the position of the node, Data is an integer, and Next is the position of the next node. Output Specification: For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input: 12345678900100 8 371120 7 8866600000 4 9999900100 1 1230968237 6 7112033218 3 0000099999 5 6823788666 8 -112309 2 33218 Sample Output: 1234567871120 7 8866688666 8 0000000000 4 9999999999 5 6823768237 6 0010000100 1 1230912309 2 3321833218 3 -1 题目大意:将一个链表分成几块，其中每块结点个数为K，现在需要把这些块从最后一块往前输出，注意块间结点不需要倒着输出。 思路：这种题有很多类似的，抽时间会做一个专题，之前刷题库时看各位大佬的代码都喜欢在遍历时就输出（根据规律遍历链表的同时也在按格式输出），之后我自己在做这种题时发现用向量先按规律遍历存下结点顺序再进行输出（将按规律遍历和输出分开），这样会使思维简单很多，举个栗子，题库有道题时翻转链表，晴神笔记上的代码就是遍历时输出，给人感觉很复杂，还有秋季的链表题也一样，但是将遍历和输出分开就简单很多，也不易出错，建议使用vector存下按规律遍历的序列再进行输出，看完这篇题解的朋友可以去做一下反转链表（A1074）那道题，用这种方法试试。 代码： 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ int address,data,next;}List[102400];int n,k,st;vector&lt;node&gt;temp,ans;int main(){ scanf(\"%d%d%d\",&amp;st,&amp;n,&amp;k); for(int i=0;i&lt;n;i++){ int address; scanf(\"%d\",&amp;address); List[address].address=address; scanf(\"%d%d\",&amp;List[address].data,&amp;List[address].next); } while(st!=-1) { temp.push_back(List[st]); st=List[st].next; } int block=temp.size()/k; for(int i=k*block;i&lt;temp.size();i++) ans.push_back(temp[i]); for(int i=block-1;i&gt;=0;i--){ for(int j=i*k;j&lt;(i+1)*k;j++) ans.push_back(temp[j]); } for(int i=0;i&lt;ans.size();i++){ if(i!=ans.size()-1) printf(\"%05d %d %05d\\n\",ans[i].address,ans[i].data,ans[i+1].address); else printf(\"%05d %d -1\\n\",ans[i].address,ans[i].data); } return 0;}","link":"/2020/03/09/%E5%86%AC%E5%AD%A37-2/"},{"title":"秋季7-1","text":"Forever “Forever number” is a positive integer A with K digits, satisfying the following constrains: the sum of all the digits of A is m;the sum of all the digits of A+1 is n; andthe greatest common divisor of m and n is a prime number which is greater than 2.Now you are supposed to find these forever numbers. Input Specification: Each input file contains one test case. For each test case, the first line contains a positive integer N (≤5). Then N lines follow, each gives a pair of K (3&lt;K&lt;10) and m (1&lt;m&lt;90), of which the meanings are given in the problem description. Output Specification: For each pair of K and m, first print in a line Case X, where X is the case index (starts from 1). Then print n and A in the following line. The numbers must be separated by a space. If the solution is not unique, output in the ascending order of n. If still not unique, output in the ascending order of A. If there is no solution, output No Solution. Sample Input: 12326 457 80 Sample Output: 123456789101112Case 110 18999910 27999910 36999910 45999910 54999910 63999910 72999910 81999910 909999Case 2No Solution 题目大意:一个数每个位上的数字加和等于给出的m，且位数等于给出的K，并同时该数加1后的数的各位加和为n，如果m和n的最小公倍数是素数且大于2，那么这个数是“永久数”，如果存在多个这种永久数，按其n从小到大排序并输出，如果n相同则按永久数从小到大输出。 思路:思路并不难，暴力破解即可，属于简单模拟，但未经优化直接从1000…(K-1个0)到9999…的话最后一个测试点会超时，所以需要优化一点点，注意到m和n的关系，如果该数字最低位不为9的话，加1没有进位，则表明n比m大1，这种情况下m和n是不存在最小公倍数的，何况是素数比2大。故这个数的最低位一定是9，有了这一点就可以从1000…9开始遍历，每次加10，这样一来就可以避免超时。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,m;struct node{ int n,A;};vector&lt;node&gt;ans;int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b); }bool isPrime(int num){ if(num&lt;2) return false; int sq=(int)sqrt(num*1.0); for(int i=2;i&lt;=sq;i++){ if(num%i==0) return false; } return true;}int getSum(int num){ int ans=0; while(num){ ans+=num%10; num/=10; } return ans;}bool cmp(node a,node b){ if(a.n!=b.n) return a.n&lt;b.n; return a.A&lt;b.A;}int main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++){ scanf(\"%d%d\",&amp;k,&amp;m); ans.clear(); printf(\"Case %d\\n\",i); int st=1; for(int j=1;j&lt;k;j++) st*=10; int ed=st*10; st+=9; while(st&lt;ed){ if(getSum(st)==m){ int temp=st+1; int n=getSum(temp); if(isPrime(gcd(m,n))&amp;&amp;gcd(m,n)&gt;2) ans.push_back(node{n,st}); } st+=10; } if(ans.size()==0) printf(\"No Solution\\n\"); else{ sort(ans.begin(),ans.end(),cmp); for(int j=0;j&lt;ans.size();j++) printf(\"%d %d\\n\",ans[j].n,ans[j].A); } } return 0;} 一点感概： 去年九月参加了这次考试，只有可怜的37分，一上来看到这道题就懵了，之前没做过多少题，读完感觉好复杂，一下子心态炸裂。3个半小时还没到我就提前退场，九月的武汉热得像火炉，去找朋友的路上手脚冰冷，最近买了时光机重来一次，发现当初真的脆弱啊，也好菜啊。非常感谢那些给我帮助的大佬，希望以后可以和各位大佬一样强。","link":"/2020/03/08/%E7%A7%8B%E5%AD%A37-1/"},{"title":"冬季7-4","text":"Cartesian Tree A Cartesian tree is a binary tree constructed from a sequence of distinct numbers. The tree is heap-ordered, and an inorder traversal returns the original sequence. For example, given the sequence { 8, 15, 3, 4, 1, 5, 12, 10, 18, 6 }, the min-heap Cartesian tree is shown by the figure. Your job is to output the level-order traversal sequence of the min-heap Cartesian tree. Input Specification: Each input file contains one test case. Each case starts from giving a positive integer N (≤30), and then N distinct numbers in the next line, separated by a space. All the numbers are in the range of int. Output Specification: For each test case, print in a line the level-order traversal sequence of the min-heap Cartesian tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line. Sample Input: 12108 15 3 4 1 5 12 10 18 6 Sample Output: 11 3 5 8 4 6 15 10 12 18 题目大意:Cartesian Tree是一种满足堆排序生成的序列，而且这种树的中序遍历和原始序列是一样的，现在给出这种树的原始序列，需要输出层序序列。 思路：有小堆的特点，表明这种树的根节点一定是最小的，尔后又表明原始序列就是中序序列（根据其他序列建树不能少中序，中序可以标定左子树右子树序列），再根据给出的图就可以知道递归建树的规律，首先每次在当前序列（第一次是原始序列）中寻找到最小的结点，该结点为根节点，在序列起点到根节点之前为左子树，在根节点后到序列终点为右子树，继续向左右递归，最后BFS即可。就是将晴神笔记里的模板稍微改一点。 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ int data; node *left,*right;}; int n,in[32],blankspace;node* create(int inL,int inR){ if(inL&gt;inR) return NULL; int k=1&lt;&lt;31-1,index; for(int i=inL;i&lt;=inR;i++){ if(in[i]&lt;k) { k=in[i]; index=i; } } node *root=new node; root-&gt;data=k; root-&gt;left=create(inL,index-1); root-&gt;right=create(index+1,inR); return root;}void BFS(node* root){ queue&lt;node*&gt;q; q.push(root); while(!q.empty()){ node* now=q.front(); q.pop(); if(blankspace==1) printf(\" \"); printf(\"%d\",now-&gt;data); blankspace=1; if(now-&gt;left!=NULL) q.push(now-&gt;left); if(now-&gt;right!=NULL) q.push(now-&gt;right); }}int main(){ scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;in[i]); node* root=create(0,n-1); BFS(root); return 0; }","link":"/2020/03/09/%E5%86%AC%E5%AD%A37-4/"},{"title":"秋季7-3","text":"Postfix Expression Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences of the operators. Input Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the i-th line corresponds to the i-th node) in the format: 1data left_child right_child where data is a string of no more than 10 characters,left_child and right_child are the indices of this node’s left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by −1. The figures 1 and 2 correspond to the samples 1 and 2, respectively. Output Specification: For each case, print in a line the postfix expression, with parentheses reflecting the precedences of the operators.There must be no space between any symbols. Sample Input1: 1234567898* 8 7a -1 -1* 4 1+ 2 5b -1 -1d -1 -1- -1 6c -1 -1 Sample Output1: 1(((a)(b)+)((c)(-(d))*)*) Sample Input2: 12345678982.35 -1 -1* 6 1- -1 4% 7 8+ 2 3a -1 -1str -1 -1871 -1 -1 Sample Output2: 1(((a)(2.35)*)(-((str)(871)%))+) 题目大意:给一个式子的二叉树结构，把这个式子按后缀表达式输出，并根据运算优先级输出括号。 思路：这个题一看就是后序遍历，但没这么简单，分析第二案例就会发现，在某节点没有左子树或者右子树时需要提前输出该结点，此时变为前序遍历，因为没有左子树或者右子树代表这是一个单目运算符，为保证优先级需要先输出，虽然我也搞不懂为什么要先输出单目运算符(+_+)? 那就这么来吧。 代码： 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ string data; int left,right;}Tree[32];int n,Hash[32],root;void postOrder(int root){ //左子树为空就前序遍历----因为单目运算，非空正常后序遍历，题目括号都加了故不需要特判括号 if(root==-1) return ; printf(\"(\"); if(Tree[root].left!=-1){ postOrder(Tree[root].left); postOrder(Tree[root].right); printf(\"%s\",Tree[root].data.c_str()); }else { printf(\"%s\",Tree[root].data.c_str()); postOrder(Tree[root].left); postOrder(Tree[root].right); } printf(\")\");} int main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++){ cin&gt;&gt;Tree[i].data&gt;&gt;Tree[i].left&gt;&gt;Tree[i].right; Hash[Tree[i].left]=Hash[Tree[i].right]=1; } for(root=1;root&lt;=n;root++) if(Hash[root]==0) break; postOrder(root); return 0;}","link":"/2020/03/08/%E7%A7%8B%E5%AD%A37-3/"},{"title":"1019 General Palindromic Number","text":"原题链接：1019 题目大意：给出一个数和一个进制，判断在该进制下这个数是否为素数，并输出该数。 Sample Input1: 127 2 Sample Output1: 12Yes1 1 0 1 1 Sample Input2: 1121 5 Sample Output2: 12No4 4 1 思路:这道题没什么好说的，直接上代码吧，在座的各位应该五分钟之内就可以AC了吧。 代码： 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt;v;int main(){ int num,radix,flag=1; cin&gt;&gt;num&gt;&gt;radix; while(num){ v.push_back(num%radix); num/=radix; } for(int i=0;i&lt;v.size();i++){ if(v[i]!=v[v.size()-1-i]){ flag=0; break; } } if(flag) cout&lt;&lt;\"Yes\"&lt;&lt;endl; else cout&lt;&lt;\"No\"&lt;&lt;endl; for(int i=v.size()-1;i&gt;=0;i--){ cout&lt;&lt;v[i]; if(i&gt;0) cout&lt;&lt;\" \"; } return 0;}","link":"/2019/10/12/1019-General-Palindromic-Number/"},{"title":"1018 Public Bike Management","text":"原题链接：1018 题目大意：为了方便对每个共享单车站进行车辆数目管理，如果一个自行车站数目是Cmax的一半那么就是完美的状态（多于Cmax的部分在遍历过程会被带回起点，少于Cmax的会从起点或者沿途超过Cmax的车站带过去补充），现在有一幅关于几个自行车站的地图以及每个站内的自行车数目，需要你给出从起点遍历完整幅图所走的最短路径，如果路径一样短，那么选择从起点带去最少数量的那一条，如果带去车的数量一样，那么选择带回数量最少的那一条。 Sample Input: 123456710 3 3 56 7 00 1 10 2 10 3 31 3 12 3 1 Sample Output: 13 0-&gt;2-&gt;3 0 思路:这是一道关于最短路径的题，但无法单独使用Dijkstra算法解决，因为带回和带去自行车的数量不是跟随路径变化而变的，需要遍历完找到一条确定路径才可以得到具体数量，所以此题需要使用Dijkstra+DFS。相信碰到这么多次关于最短路径的题目各位应该不陌生了，所以我就直接给出AC代码了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=520;const int inf=1&lt;&lt;31-1;int G[maxn][maxn],dis[maxn],weight[maxn];bool vis[maxn];int Cmax,n,Spl,m,MinNeed=inf,MinBack=inf;vector&lt;int&gt;pre[maxn],path,temp;void Dijkstra(int index){ fill(dis,dis+maxn,inf); fill(vis,vis+maxn,false); dis[index]=0; for(int i=0;i&lt;=n;i++){ int u=-1,Min=inf; for(int j=0;j&lt;=n;j++){ if(vis[j]==false&amp;&amp;dis[j]&lt;Min){ Min=dis[j]; u=j; } } if(u==-1) return ; vis[u]=true; for(int v=0;v&lt;=n;v++){ if(vis[v]==false&amp;&amp;G[u][v]!=inf){ if(dis[u]+G[u][v]&lt;dis[v]){ dis[v]=dis[u]+G[u][v]; pre[v].clear(); pre[v].push_back(u); }else if(dis[u]+G[u][v]==dis[v]) pre[v].push_back(u); } } }}void DFS(int index){ temp.push_back(index); if(index==0){ int need=0,back=0; for(int i=temp.size()-1;i&gt;=0;i--){ if(weight[temp[i]]&gt;0) back+=weight[temp[i]]; else{ if(back&gt;abs(weight[temp[i]])) back-=abs(weight[temp[i]]); else{ need+=abs(weight[temp[i]])-back; back=0; } } } if(need&lt;MinNeed){ MinNeed=need; MinBack=back; path=temp; }else if(need==MinNeed&amp;&amp;back&lt;MinBack){ MinBack=back; path=temp; } temp.pop_back(); return ; } for(int i=0;i&lt;pre[index].size();i++){ DFS(pre[index][i]); } temp.pop_back();}int main(){ cin&gt;&gt;Cmax&gt;&gt;n&gt;&gt;Spl&gt;&gt;m; fill(G[0],G[0]+maxn*maxn,inf); for(int i=1;i&lt;=n;i++){ cin&gt;&gt;weight[i]; weight[i]-=Cmax/2; } for(int i=0;i&lt;m;i++){ int u,v,edge; cin&gt;&gt;u&gt;&gt;v&gt;&gt;edge; G[u][v]=G[v][u]=edge; } Dijkstra(0); DFS(Spl); cout&lt;&lt;MinNeed&lt;&lt;\" \"; for(int i=path.size()-1;i&gt;=0;i--){ cout&lt;&lt;path[i]; if(i&gt;0) cout&lt;&lt;\"-&gt;\"; } cout&lt;&lt;\" \"&lt;&lt;MinBack; return 0;}","link":"/2019/10/12/1018-Public-Bike-Management/"},{"title":"秋季7-4","text":"Dijkstra Sequence Dijkstra’s algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later. In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let’s call it Dijkstra sequence, is generated by Dijkstra’s algorithm. On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not. Input Specification: Each input file contains one test case. For each case, the first line contains two positive integers Nv (≤103) and Ne (≤105), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to Nv. Then Ne lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤100) of the edge. It is guaranteed that the given graph is connected. Finally the number of queries, K, is given as a positive integer no larger than 100, followed by K lines of sequences, each contains a permutationof the Nv vertices. It is assumed that the first vertex is the source for each sequence. All the inputs in a line are separated by a space. Output Specification: For each of the K sequences, print in a line Yes if it is a Dijkstra sequence, or No if not. Sample Input: 123456789101112135 71 2 21 5 12 3 12 4 12 5 23 5 13 4 145 1 3 4 25 3 1 2 42 3 4 5 13 2 1 5 4 Sample Output: 1234YesYesYesNo 题目大意:给出几串序列，判断这些序列是不是迪杰斯特拉序列，所谓迪杰斯特拉序列是由迪杰斯特拉算法每一步所得到的结点序号组成的序列，但有时根据迪杰斯特拉算法得出的序列并不唯一，因为有些结点可能和起点的距离一样。 思路：迪杰斯特拉算法每一次都是找到当前距离起点最近的结点，所以无论当前有几个结点和起点距离一样，它们和起点的距离肯定会比下一个结点距离起点近或者一样，故可以利用迪杰斯特拉算法得出一串序列，后和题目给的序列进行对比,只要后面有距离小于前面的结点则表示不是迪杰斯特拉序列。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1&lt;&lt;31-1;int n,m,query,adj[1024][1024],dis[1024][1024];bool vis[1024];void Dijkstra(int index){ fill(dis[index],dis[index]+1024,inf); fill(vis,vis+1024,false); dis[index][index]=0; for(int i=1;i&lt;=n;i++){ int u=-1,Min=inf; for(int j=1;j&lt;=n;j++){ if(vis[j]==false&amp;&amp;dis[index][j]&lt;Min){ u=j; Min=dis[index][j]; } } if(u==-1) return ; vis[u]=true; for(int v=1;v&lt;=n;v++){ if(vis[v]==false&amp;&amp;adj[u][v]!=inf){ if(dis[index][u]+adj[u][v]&lt;dis[index][v]) dis[index][v]=dis[index][u]+adj[u][v]; } } }}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); fill(adj[0],adj[0]+1024*1024,inf); for(int i=0;i&lt;m;i++){ int u,v,d; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;d); adj[u][v]=adj[v][u]=d; } scanf(\"%d\",&amp;query); int Hash[n+1]={0}; while(query--){ int temp[n+1],flag=1; for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;temp[i]); if(Hash[temp[1]]==0) { Dijkstra(temp[1]); Hash[temp[1]]=1; } for(int i=n;i&gt;2;i--){ if(dis[temp[1]][temp[i]]&lt;dis[temp[1]][temp[i-1]]) { flag=0; break; } } if(flag) printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0;}","link":"/2020/03/08/%E7%A7%8B%E5%AD%A37-4/"},{"title":"秋季7-2","text":"Merging Linked Lists Given two singly linked lists L1=a1→a2→⋯→an−1→an and L2=b1→b2→⋯→bm−1→bm. If n≥2m, you are supposed to reverse and merge the shorter one into the longer one to obtain a list like a​1→a2→bm→a3→a​4→bm−1⋯. For example, given one list being 6→7 and the other one 1→2→3→4→5, you must output 1→2→7→3→4→6→5. Input Specification: Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes of L1 and L2, plus a positive N (≤105) which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1. Then N lines follow, each describes a node in the format: Data Next```12345678where Address is the position of the node, Data is a positive integer no more than 105 , and Next is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one.**Output Specification**:For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.**Sample Input**: 00100 01000 702233 2 3489100100 6 0000134891 3 1008601000 1 0223300033 5 -110086 4 0003300001 7 -1 12**Sample Output**: 01000 1 0223302233 2 0000100001 7 3489134891 3 1008610086 4 0010000100 6 0003300033 5 -1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748**题目大意**:给出两个链表，其中一个的长度至少是另一个的两倍，现在需要从长链表结点开始，每隔一个短链表结点输出两个长链表结点，注意，短链表要从后往前输出。**思路**:建议碰到对链表操作的题都使用向量来模拟，这样会很方便，这种题还需操作前剔除无效结点。用两个向量分别按次序存储两个链表，然后reverse短链表，尔后从短链表末尾开始向前遍历，每次先输出两个正序长链表结点再输出一个短链表结点。**代码**：```c++#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ int address,data,next;}rec[102400];int st1,st2,n;vector&lt;node&gt;ans,ans1,ans2;int main(){ scanf(\"%d%d%d\",&amp;st1,&amp;st2,&amp;n); for(int i=0;i&lt;n;i++){ int address; scanf(\"%d\",&amp;address); rec[address].address=address; scanf(\"%d%d\",&amp;rec[address].data,&amp;rec[address].next); } while(st1!=-1) { ans1.push_back(rec[st1]); st1=rec[st1].next; } while(st2!=-1) { ans2.push_back(rec[st2]); st2=rec[st2].next; } if(ans1.size()&gt;=2*ans2.size()){ reverse(ans2.begin(),ans2.end()); for(int i=0;i&lt;ans2.size();i++){ ans.push_back(ans1[i*2]); ans.push_back(ans1[i*2+1]); ans.push_back(ans2[i]); } for(int i=2*ans2.size();i&lt;ans1.size();i++) ans.push_back(ans1[i]); }else if(ans2.size()&gt;=2*ans1.size()){ reverse(ans1.begin(),ans1.end()); for(int i=0;i&lt;ans1.size();i++){ ans.push_back(ans2[i*2]); ans.push_back(ans2[i*2+1]); ans.push_back(ans1[i]); } for(int i=2*ans1.size();i&lt;ans2.size();i++) ans.push_back(ans2[i]); } for(int i=0;i&lt;ans.size();i++){ if(i!=ans.size()-1) printf(\"%05d %d %05d\\n\",ans[i].address,ans[i].data,ans[i+1].address); else printf(\"%05d %d -1\\n\",ans[i].address,ans[i].data); } return 0;}","link":"/2020/03/08/%E7%A7%8B%E5%AD%A37-2/"},{"title":"1118 Birds in Forest","text":"原题链接：1118 题目大意：给在树上的鸟拍照，假定所有鸟类只要在同一张照片里即为属于同一棵树（只要照片里有一样的鸟类出现就代表是同一棵树），需要统计树的个数以及鸟的个数，给出两个鸟类的编号需要判断这两类鸟是不是在同一棵树上。 Sample Input: 1234567843 10 1 22 3 44 1 5 7 83 9 6 4210 53 7 Sample Output: 1232 10YesNo 思路:这道题考察并查集，需要注意题目需要根据每张照片（可以理解为每棵树）里的鸟类来并这些照片（树），理解了之后就好做了。晴神的板子用起来。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;int n,query,father[10240],root[10240],ans;unordered_set&lt;int&gt;st;int findFather(int a){ int x=a; while(a!=father[a]) a=father[a]; while(x!=father[x]){ int z=x; x=father[x]; father[z]=a; } return a;}void Union(int a,int b){ int fa=findFather(a),fb=findFather(b); if(fa!=fb) father[fa]=fb;}int main(){ scanf(\"%d\",&amp;n); for(int i=0;i&lt;10240;i++) father[i]=i; for(int i=0;i&lt;n;i++){ int k,u,v; scanf(\"%d%d\",&amp;k,&amp;u); st.insert(u); for(int j=0;j&lt;k-1;j++){ scanf(\"%d\",&amp;v); st.insert(v); Union(u,v); } } for(auto it=st.begin();it!=st.end();it++) root[findFather(*it)]++; for(auto it=st.begin();it!=st.end();it++) if(root[*it]!=0) ans++; printf(\"%d %d\\n\",ans,st.size()); scanf(\"%d\",&amp;query); while(query--){ int u,v; scanf(\"%d%d\",&amp;u,&amp;v); if(findFather(u)==findFather(v)) printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0;}","link":"/2020/03/11/1118-Birds-in-Forest/"},{"title":"1107 Social Clusters","text":"原题链接：1107 题目大意：社交软件里会根据每位用户的爱好给爱好中有相同的用户分成一些块（clusters），现在给出N个用户的爱好，请输出clusters的个数，并输出每个cluster包涵的人数(从大到小的顺序)。 Sample Input: 12345678983: 2 7 101: 42: 5 31: 41: 31: 44: 6 8 1 51: 4 Sample Output: 1234 3 1 思路:这是一个并查集的题目，先根据每个用户的爱好进行分类，尔后统计即可，把晴神笔记中的板子背下来并理解就好办了。但根据我个人理解并查集难在找出到底是根据什么来将什么并在一起（和后面更新的1118对比），比如这题是根据每个用户的爱好来把爱好相同的用户并在一起，所以读懂题目很关键。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int n,father[1024],Hash[1024],root[1024],blankspace;vector&lt;int&gt;ans;int findFather(int a){ int x=a; while(a!=father[a]) a=father[a]; while(x!=father[x]){ int z=x; x=father[x]; father[z]=a; } return a;}void Union(int a,int b){ int fa=findFather(a),fb=findFather(b); if(fa!=fb) father[fa]=fb;}int main(){ for(int i=0;i&lt;1024;i++) father[i]=i; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++){ int k; scanf(\"%d:\",&amp;k); for(int j=0;j&lt;k;j++){ int u; scanf(\"%d\",&amp;u); if(Hash[u]==0) Hash[u]=i; Union(i,Hash[u]); } } for(int i=1;i&lt;=n;i++) root[findFather(i)]++; for(int i=1;i&lt;=n;i++) if(root[i]!=0) ans.push_back(root[i]); sort(ans.begin(),ans.end()); printf(\"%d\\n\",ans.size()); for(int i=ans.size()-1;i&gt;=0;i--){ if(blankspace==1) printf(\" \"); printf(\"%d\",ans[i]); blankspace=1; } return 0;}","link":"/2020/03/11/1107-Social-Clusters/"},{"title":"1095 Cars on Campus","text":"原题链接：1095 题目大意：学校每天都有很多车进出，现在给出一天时间内的进出记录，每条记录都是车牌号，时间（hh:mm:ss）还有状态（进则“in”出则“out”），现在要统计某一时刻内校园里的车辆，还需给出当天在学校里停留时间最长的车牌以及停留时间，如果不唯一则按车牌号的字母序输出，注意，一个合法的记录应当包涵一个in状态和一个out状态，只有合法的记录才纳入统计。 Sample Input: 12345678910111213141516171819202122232416 7JH007BD 18:00:01 inZD00001 11:30:08 outDB8888A 13:00:00 outZA3Q625 23:59:50 outZA133CH 10:23:00 inZD00001 04:09:59 inJH007BD 05:09:59 inZA3Q625 11:42:01 outJH007BD 05:10:33 inZA3Q625 06:30:50 inJH007BD 12:23:42 outZA3Q625 23:55:00 inJH007BD 12:24:23 outZA133CH 17:11:22 outJH007BD 18:07:01 outDB8888A 06:30:50 in05:10:0006:30:5011:00:0012:23:4214:00:0018:00:0023:59:00 Sample Output: 123456781452101JH007BD ZD00001 07:20:09 思路:先将每个记录按车牌序，时间序的优先级排序，再用一个映射（map）进行统计最长时间，同时记录是否为合法记录，再进行一次排序，这次以合法序，时间序的优先级排序，结束后进行查询，由于题目上说每次给的查询时间时递增的，故只需遍历一遍即可，当前记录为合法且小于等于查询时间时，若状态为in则当前车辆+1，若为out那么-1。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ string plate,status; int sum,flag;}rec[102400];int n,query,ans;map&lt;string,int&gt;mp;bool cmp(node a,node b){ if(a.plate!=b.plate) return a.plate&lt;b.plate; return a.sum&lt;b.sum;}bool cmp1(node a,node b){ if(a.flag!=b.flag) return a.flag&gt;b.flag; return a.sum&lt;b.sum;}int main(){ scanf(\"%d%d\",&amp;n,&amp;query); for(int i=0;i&lt;n;i++){ int hh,mm,ss; cin&gt;&gt;rec[i].plate; scanf(\"%d:%d:%d\",&amp;hh,&amp;mm,&amp;ss); cin&gt;&gt;rec[i].status; rec[i].sum=hh*3600+mm*60+ss; } sort(rec,rec+n,cmp); for(int i=0;i&lt;n;i++){ if(rec[i].plate==rec[i+1].plate&amp;&amp;rec[i].status==\"in\"&amp;&amp;rec[i+1].status==\"out\"){ mp[rec[i].plate]+=rec[i+1].sum-rec[i].sum; rec[i].flag=rec[i+1].flag=1; if(mp[rec[i].plate]&gt;ans) ans=mp[rec[i].plate]; } } sort(rec,rec+n,cmp1); int Index=0,cnt=0; while(query--){ int hh,mm,ss,sum; scanf(\"%d:%d:%d\",&amp;hh,&amp;mm,&amp;ss); sum=hh*3600+mm*60+ss; for(;Index&lt;n;Index++){ if(rec[Index].flag==0||rec[Index].sum&gt;sum) break; else { if(rec[Index].status==\"in\") cnt++; else cnt--; } } printf(\"%d\\n\",cnt); } for(auto it=mp.begin();it!=mp.end();it++) if(it-&gt;second==ans) printf(\"%s \",it-&gt;first.c_str()); printf(\"%02d:%02d:%02d\",ans/3600,ans%3600/60,ans%60); return 0;}","link":"/2020/03/11/1095-Cars-on-Campus/"},{"title":"1104 Sum of Number Segments","text":"原题链接：1104 题目大意：给定一串序列，把这串序列能构成的子集的和保留两位小数输出。 Sample Input: 1240.1 0.2 0.3 0.4 Sample Output: 15.00 思路:通过列方程得出序号i（从1开始）和当前第i个元素要加的次数index之间的关系为index=（n+1-i）*i,其中n为序列大小。 代码： 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int n;double ans;int main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++){ double temp; scanf(\"%lf\",&amp;temp); ans+=temp*(n+1-i)*i; } printf(\"%.2f\",ans); return 0;}","link":"/2020/03/13/1104-Sum-of-Number-Segments/"},{"title":"1102 Invert a Binary Tree","text":"原题链接：1102 题目大意：把一颗二叉树左右交换结点后输出其层序序列和中序序列。 Sample Input: 12345678981 -- -0 -2 7- -- -5 -4 6 Sample Output: 123 7 2 6 4 0 5 16 5 7 4 3 2 0 1 思路:用前序遍历或后序遍历将二叉树左右交换，不能用中序，因为中序遍历最后结果没有进行左右交换，可以这么想，按照中序遍历的顺序，先左子树，将左子树全部交换后，又在根节点处将左右交换，此时右子树就是之前交换过的左子树，尔后又把当前右子树（之前交换过的左子树）左右交换，又变回原样。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ int left,right;}Tree[16];int n,Hash[16],blankspace,root;void preOrder(int root){ if(root==-1) return ; swap(Tree[root].left,Tree[root].right); preOrder(Tree[root].left); preOrder(Tree[root].right);}void BFS(int root){ queue&lt;int&gt;q; q.push(root); while(!q.empty()){ int now=q.front(); q.pop(); if(blankspace==1) printf(\" \"); printf(\"%d\",now); blankspace=1; if(Tree[now].left!=-1) q.push(Tree[now].left); if(Tree[now].right!=-1) q.push(Tree[now].right); } printf(\"\\n\"); blankspace=0;}void inOrder(int root){ if(root==-1) return ; inOrder(Tree[root].left); if(blankspace==1) printf(\" \"); printf(\"%d\",root); blankspace=1; inOrder(Tree[root].right);}int main(){ scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++){ string u,v; cin&gt;&gt;u&gt;&gt;v; if(u!=\"-\") { Tree[i].left=stoi(u); Hash[stoi(u)]=1; } else Tree[i].left=-1; if(v!=\"-\") { Tree[i].right=stoi(v); Hash[stoi(v)]=1; } else Tree[i].right=-1; } for(root=0;root&lt;n;root++) if(Hash[root]==0) break; preOrder(root); BFS(root); inOrder(root); return 0;}","link":"/2020/03/13/1102-Invert-a-Binary-Tree/"},{"title":"1103 Integer Factorization","text":"原题链接：1103 题目大意：给定正数N，K，P，要求将N用K个P次方的数的和表示。 Sample Input1: 1169 5 2 Sample Output1: 1169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2 Sample Input2: 1169 167 3 Sample Output2: 1Impossible 思路:用一个向量fac存储不超过N的i（从1开始）的P次方数，从末尾开始遍历，如果当前加和大于N或者个数大于K或者遍历到fac尾需要返回，遍历终点是和等于N且个数等于K，如果每个因子和大于当前因子和则交换向量ans和temp并返回。 代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,p,Max=-1,blankspace;vector&lt;int&gt;fac,temp,ans;void DFS(int index,int sum,int facSum,int cnt){ if(sum&gt;n||cnt&gt;k||index&lt;0) return ; if(sum==n&amp;&amp;cnt==k){ if(facSum&gt;Max){ Max=facSum; ans=temp; return ; } } temp.push_back(index); DFS(index,sum+fac[index],facSum+index,cnt+1); temp.pop_back(); DFS(index-1,sum,facSum,cnt);}int main(){ scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;p); for(int i=1;i&lt;=n;i++){ if(pow(i,p)&gt;n) break; fac.push_back(pow(i,p)); } DFS(fac.size()-1,0,0,0); if(ans.size()==0) printf(\"Impossible\\n\"); else { printf(\"%d = \",n); for(int i=0;i&lt;ans.size();i++){ if(blankspace==1) printf(\" + \"); printf(\"%d^%d\",ans[i]+1,p); blankspace=1; } } return 0;}","link":"/2020/03/13/1103-Integer-Factorization/"},{"title":"1101 Quick Sort","text":"原题链接：1101 题目大意：快速排序中有中枢结点的概念（简称结点），在该结点前的所有结点键值都比其键值小，在该结点后的结点的键值都比其大，因而可将此结点当作标定进行排序操作。给出一串序列，请找出其中的结点个数，并增序输出。 Sample Input: 1251 3 2 4 5 Sample Output: 1231 4 5 思路:利用两个数组Max，Min进行记录，其中Max数组记录当前第i个结点前最大的结点键值，不包括当前结点键值，Min数组记录当前第i个结点后最小的结点键值，同样不包括当前结点键值，最后从头至尾遍历序列，如果其中第i个结点键值大于Max[i]，小于Min[i]就表明此结点可为关键结点。 代码： 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int n,num[102400],Max[102400],Min[102400],blankspace;set&lt;int&gt;st;int main(){ scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++){ scanf(\"%d\",&amp;num[i]); if(i==0) Max[i]=num[i]-1; else Max[i]=max(Max[i-1],num[i-1]); } for(int i=n-1;i&gt;=0;i--){ if(i==n-1) Min[i]=num[i]+1; else Min[i]=min(Min[i+1],num[i+1]); } for(int i=0;i&lt;n;i++){ if(num[i]&gt;Max[i]&amp;&amp;num[i]&lt;Min[i]) st.insert(num[i]); } printf(\"%d\\n\",st.size()); for(auto it=st.begin();it!=st.end();it++){ if(blankspace==1) printf(\" \"); printf(\"%d\",*it); blankspace=1; } printf(\"\\n\"); return 0;}","link":"/2020/03/13/1101-Quick-Sort/"}],"tags":[{"name":"PAT(Advanced Level)","slug":"PAT-Advanced-Level","link":"/tags/PAT-Advanced-Level/"},{"name":"start","slug":"start","link":"/tags/start/"},{"name":"pat真题","slug":"pat真题","link":"/tags/pat%E7%9C%9F%E9%A2%98/"}],"categories":[{"name":"字符输出","slug":"字符输出","link":"/categories/%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA/"},{"name":"树的遍历","slug":"树的遍历","link":"/categories/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"name":"哈希","slug":"哈希","link":"/categories/%E5%93%88%E5%B8%8C/"},{"name":"最短路径","slug":"最短路径","link":"/categories/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"简单模拟","slug":"简单模拟","link":"/categories/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F/"},{"name":"排序","slug":"排序","link":"/categories/%E6%8E%92%E5%BA%8F/"},{"name":"动态规划","slug":"动态规划","link":"/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"图的遍历","slug":"图的遍历","link":"/categories/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"},{"name":"模拟","slug":"模拟","link":"/categories/%E6%A8%A1%E6%8B%9F/"},{"name":"数学问题","slug":"数学问题","link":"/categories/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"},{"name":"二分法","slug":"二分法","link":"/categories/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"静态链表","slug":"静态链表","link":"/categories/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"},{"name":"成长","slug":"成长","link":"/categories/%E6%88%90%E9%95%BF/"},{"name":"并查集","slug":"并查集","link":"/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"深度优先搜索","slug":"深度优先搜索","link":"/categories/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]}